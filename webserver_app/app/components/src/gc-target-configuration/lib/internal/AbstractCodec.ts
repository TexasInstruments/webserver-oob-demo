/**
 *  Copyright (c) 2020, 2021 Texas Instruments Incorporated
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  *   Redistributions of source code must retain the above copyright
 *  notice, this list of conditions and the following disclaimer.
 *  notice, this list of conditions and the following disclaimer in the
 *  documentation and/or other materials provided with the distribution.
 *  *   Neither the name of Texas Instruments Incorporated nor the names of
 *  its contributors may be used to endorse or promote products derived
 *  from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import { IEncoderType, IDecoderType, NoopDataEncoderType, NoopDataDecoderType } from './CodecDataTypes';
import { codecRegistry } from './CodecRegistry';
import { ICodecBaseParams } from '../ICodecBaseParams';
import { Events } from '../../../gc-core-assets/lib/Events';
import { ITransport } from './ITransport';

/* eslint-disable @typescript-eslint/no-empty-interface */
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * Callback interface for logging error, warning, progress, and debug messages.
 */
export interface IConnectionLog {
    /**
     * Method to test if still connecting to the target.  This method throws an exception if the connection should be stopped.
     */
    assertStillConnecting(): void;

    /**
     * Method to add a progress message.
     */
    addProgressMessage(message: string, tooltip?: string): void;

    /**
     * Method to add an error message.
     */
    addErrorMessage(message: string, tooltip?: string): void;

    /**
     * Method to add a warning message.
     */
    addWarningMessage(message: string, tooltip?: string): void;

    /**
     * Method to add a debug message.
     */
    addDebugMessage(message: string): void;
}

/**
 * Base interface for all codecs to implement
 */
export interface ICodecBase extends ICodecBaseParams {
    /**
     * Unique identifier for the codec.  Used to register codes with the codecRegistry.
     */
    readonly id: string;

    /**
     * Method called when the codec is no longer part of the active configuration.
     */
    deconfigure?(): void;

    /**
     * Method called when the codec becomes a part of the active configuration.
     */
    configure?(): void;

    /**
     * Method called to connect the codec.
     *
     * @param transport transport that the codec is connecting under.
     */
    onConnect?(transport: ITransport): Promise<void>;

    /**
     * Method called to disconnect the codec.
     *
     * @param transport transport that the codec is disconnecting under.
     */
    onDisconnect?(transport: ITransport): Promise<void>;

    /**
     * Method ping the target to determine if the codec is still connected to the target.  If there is any issue with
     * pinging the target, an exception must be thrown.
     */
    ping?(): Promise<void>;

    /**
     * Method called to dispose of the codec, and make it available for garbage collection.
     */
    dispose(): void;
}

/**
 * Generic interface for all encoders.
 */
export interface IEncoder<RX, TX> extends ICodecBase {

    /**
     * Type of input supported by this encoder.
     */
    readonly encoderInputType: IEncoderType<TX>;

    /**
     * Type of output generated by this encoder.
     */
    readonly encoderOutputType: IDecoderType<RX>;

    /**
     * Method used to chain a child decoder to this encoder.
     *
     * @param child decoder that is the source of data going to the target to encode.
     */
    addChildDecoder(child: RX): void;
}

/**
 * Generic interface for all decoders
 */
export interface IDecoder<RX, TX> extends ICodecBase {
    /**
     * Type of input supported by this decoder.
     */
    readonly decoderInputType: IDecoderType<RX>;

    /**
     * Type of output generated by this decoder.
     */
    readonly decoderOutputType: IEncoderType<TX>;

    /**
     * Method to set chain the parent encoder to this decoder.
     *
     * @param parent encoder that is the source of data coming from the target to decode.
     */
    setParentEncoder(parent: TX): void;
}

/**
 * Generic interface for all codecs.  A codec is both an encoder and a decoder.
 */
export interface ICodec<RXIN, TXOUT, RXOUT, TXIN> extends IDecoder<RXIN, TXOUT>, IEncoder<RXOUT, TXIN> {
}

/**
 * Generic interface for encoders that encode data.
 */
export interface IDataEncoder<TX> extends IEncoder<IDataDecoder<unknown>, IDataEncoder<TX>> {
    /**
     * Method called to encode data and send to the target.
     *
     * @param data input data to encode and send to the target.
     */
    encode(data: TX): void;
}

/**
 * Generic interface for decoders that decode data.
 */
export interface IDataDecoder<RX> extends IDecoder<IDataDecoder<RX>, IDataEncoder<unknown>> {
    /**
     * Method called to decode data coming from the target.
     *
     * @param data input data to decode that is coming from the target.
     * @returns true if the connection is still ok.  false or an error message to terminate this transport's connection.
     */
    decode(data: RX): Error | boolean;
}

/**
 * Generic interface for codecs that encode and decode data.  Data codes are both data encoders and data decoders.
 */
export interface IDataCodec<RX, TX> extends IDataDecoder<RX>, IDataEncoder<TX> {
}

/**
 * Null decoder to be used in lieu of null pointers.
 */
export interface INoopDecoder {
}

/**
 * Null encoder to be used in lieu of null pointers.
 */
export interface INoopEncoder {
}

/**
 * Null codec to be used in lieu of null pointers.
 */
export const nullDataCodec = new (class implements IDataDecoder<any>, IDataEncoder<any> {
    decoderInputType = NoopDataDecoderType;
    decoderOutputType = NoopDataEncoderType;
    encoderInputType = NoopDataEncoderType;
    encoderOutputType = NoopDataDecoderType;
    addChildDecoder() {
    }
    setParentEncoder() {
    }
    id: string = '';
    dispose() {
    }
    encode(data: any): void {
    }
    decode(data: any): boolean | Error {
        return false;
    }
})();

/**
 * Abstract Encoder implementation that manages the targetDecoder pointer.
 */
export abstract class AbstractEncoder<RX, TX> extends Events implements IEncoder<RX, TX> {
    protected abstract targetDecoder: RX;
    readonly abstract params: ICodecBaseParams;

    constructor(public readonly id: string, public readonly encoderInputType: IEncoderType<TX>, public readonly encoderOutputType: IDecoderType<RX>) {
        super();
        codecRegistry.register(this);
    }

    addChildDecoder(child: RX) {
        this.targetDecoder = child;
    }

    get optional() {
        return this.params.optional;
    }

    get deviceId() {
        return this.params.deviceId;
    }

    toString() {
        return `codec id="${this.id}"`;
    }

    dispose() {
    }
}

/**
 * Abstract decoder implementation that manages the targetEncoder pointer.
 */
export abstract class AbstractDecoder<RX, TX> extends Events implements IDecoder<RX, TX> {
    protected abstract targetEncoder: TX;
    readonly abstract params: ICodecBaseParams;

    constructor(public readonly id: string, public readonly decoderInputType: IDecoderType<RX>, readonly decoderOutputType: IEncoderType<TX>) {
        super();
        codecRegistry.register(this);
    }

    setParentEncoder(parent: TX) {
        this.targetEncoder = parent;
    }

    get optional() {
        return this.params.optional;
    }

    get deviceId() {
        return this.params.deviceId;
    }

    toString() {
        return `codec id="${this.id}"`;
    }

    dispose() {
        codecRegistry.unregister(this);
    }
}

/**
 * Abstract codec implementation that manages both the targetEncoder, and the targetDecoder, pointers.
 */
export abstract class AbstractCodec<RXIN, TXOUT, RXOUT, TXIN> extends AbstractDecoder<RXIN, TXOUT> implements IEncoder<RXOUT, TXIN> {
    constructor(id: string, decoderInputType: IDecoderType<RXIN>, decoderOutputType: IEncoderType<TXOUT>,
        public readonly encoderOutputType: IDecoderType<RXOUT>, public readonly encoderInputType: IEncoderType<TXIN>) {
        super(id, decoderInputType, decoderOutputType);
    }
    readonly abstract params: ICodecBaseParams;
    protected abstract targetDecoder: RXOUT;

    addChildDecoder(child: RXOUT) {
        this.targetDecoder = child;
    }
}

/**
 * Abstract data decodec implementation that manages the targetEncoder pointer.
 */
export abstract class AbstractDataDecoder<RX, TX> extends AbstractDecoder<IDataDecoder<RX>, IDataEncoder<TX>> {
    constructor(id: string, decoderInputType: IDecoderType<IDataDecoder<RX>>, decoderOutputType: IEncoderType<IDataEncoder<TX>>) {
        super(id, decoderInputType, decoderOutputType);
    }
    readonly abstract params: ICodecBaseParams;
    protected targetEncoder: IDataEncoder<TX> = nullDataCodec;

    deconfigure() {
        this.targetEncoder = nullDataCodec;
    }

    abstract decode(data: RX): boolean | Error;
}

/**
 * Abstract data codec implementation that manages both the targetEncoder, and the targetDecoder pointers.
 */
export abstract class AbstractDataCodec<RXIN, TXOUT, RXOUT, TXIN> extends AbstractDataDecoder<RXIN, TXOUT> implements IEncoder<IDataDecoder<RXOUT>, IDataEncoder<TXIN>> {
    constructor(id: string, decoderInputType: IDecoderType<IDataDecoder<RXIN>>, decoderOutputType: IEncoderType<IDataEncoder<TXOUT>>,
        public readonly encoderOutputType: IDecoderType<IDataDecoder<RXOUT>>, public readonly encoderInputType: IEncoderType<IDataEncoder<TXIN>>) {
        super(id, decoderInputType, decoderOutputType);
    }
    readonly abstract params: ICodecBaseParams;
    protected targetDecoder: IDataDecoder<RXOUT> = nullDataCodec;

    addChildDecoder(child: IDataDecoder<RXOUT>) {
        if (this.targetDecoder && this.targetDecoder !== nullDataCodec) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            this.targetDecoder = new DataDecoderTap<RXOUT, TXIN>(child, this.targetDecoder, this.encoderOutputType, this.encoderInputType);
        } else {
            this.targetDecoder = child;
        }
    }

    deconfigure() {
        super.deconfigure();
        this.targetDecoder = nullDataCodec;
    }

    abstract encode(data: TXIN): void;
}

class DataDecoderTap<RX, TX> extends AbstractDataDecoder<RX, TX> {
    constructor(private readonly targetDecoder: IDataDecoder<RX>, private readonly next: IDataDecoder<RX>, decoderInputType: IDecoderType<IDataDecoder<RX>>, decoderOutputType: IEncoderType<IDataEncoder<TX>>) {
        super('tap', decoderInputType, decoderOutputType);
    }
    readonly params: ICodecBaseParams = {};

    decode(data: RX): boolean | Error {
        const result1 = this.targetDecoder.decode(data);
        const result2 = this.next.decode(data);
        return result1 instanceof Error ? result1 : result2 instanceof Error ? result2 : result1 || result2;
    }
}